#+auto_tangle: t
* imports
#+begin_src elisp :tangle yes
    ;;; quickcheck.el --- Quickcheck clone       -*- lexical-binding: t; -*-  
        (require 'seq)
        (require 'dash)
        (require 'ert)
        (require 'calc-comb)
        (require 'cl-lib)

  (let ((parent-directory (file-name-directory (or load-file-name buffer-file-name))))
    (file-name-concat parent-directory "quickcheck"))
  (require 'quickcheck)
#+END_SRC

#+RESULTS:
: quickcheck

* Utilities
** DONE Test times
#+begin_src elisp :tangle yes
  (ert-deftest times ()    
    (let* ((test-n (random 255))
  	 (test-constant (random))
  	 (actual-result (times (cl-constantly test-constant) test-n))
  	 (actual-constant-count (funcall #'seq-count (apply-partially #'eql test-constant) actual-result)))      
    (should (eql actual-constant-count test-n))))

#+END_SRC

#+RESULTS:
: (1 . 1)

** DONE Test times-no-args
#+begin_src elisp :tangle yes

  (ert-deftest-n-times times-no-args 100
    (let* ((test-n (random 255))
  	 (test-constant (random))
  	 (actual-result (times-no-args (lambda () test-constant) test-n))
  	 (actual-constant-count (funcall #'seq-count (apply-partially #'eql test-constant) actual-result)))      
    (should (eql actual-constant-count test-n))))

#+END_SRC


** DONE Test non-zero-bounded-modular-addition
#+BEGIN_SRC emacs-lisp :tangle yes

      (ert-deftest-n-times non-zero-bounded-modular-addition-max-test 100
        (let* ((range-max (random 100000000))
      	 (range-min (- range-max (random range-max) 2))
      	 (increase 1)
      	 (expected-result range-min)
      	 (current-number (1- range-max))
      	 (actual-result (non-zero-bounded-modular-addition (list range-min range-max) increase current-number)))
  			    (should (eql actual-result expected-result))))


      (ert-deftest-n-times non-zero-bounded-modular-addition-min-test 100
        (let* ((range-max (random 10000000))
    	 (range-min (- range-max (random range-max) 2))
    	 (increase 1)
    	 (expected-result (1+ range-min))
    	 (current-number range-min)
    	 (actual-result (non-zero-bounded-modular-addition (list range-min range-max) increase current-number)))
  			    (should (eql actual-result expected-result))))

    (ert-deftest-n-times non-zero-bounded-modular-addition-basic-integer-test 100
      (let* ((range-max (random 10000000))
    	 (range-min (- range-max (random range-max) 2))
    	 (increase (random range-max))
    	 (current-number (random range-max))
    	 (actual-result (non-zero-bounded-modular-addition (list range-min range-max) increase current-number)))
  			 (should (eql (and (greater-than-or-equal actual-result range-min) (less-than actual-result range-max)) t))))


#+END_SRC

** DONE Test random-float-between-0-and-1
#+begin_src elisp :tangle yes
  (ert-deftest-n-times random-float-between-0-and-1 100
    (should (floatp (random-float-between-0-and-1))))  		     
#+END_SRC

** DONE Test scale-float-to-range
#+begin_src elisp :tangle yes
  (ert-deftest-n-times scale-float-to-range 100    
      (let* ((test-max (random 10000000))
  	   (test-min (- test-max (random test-max) 2))
  	   (test-float-to-scale (convert-calc-value-into-lisp (math-random-float)))
  	   (actual-float (scale-float-to-range (list test-min test-max) test-float-to-scale)))
        (should (greater-than-or-equal actual-float test-min))
        (should (less-than actual-float test-max))))
#+END_SRC


** calc-extensions
*** DONE Test convert-calc-value-into-lisp
#+begin_src elisp :tangle yes
  (ert-deftest-n-times convert-calc-value-into-lisp 100
    (should (floatp (convert-calc-value-into-lisp (math-gaussian-float)))))  		     
#+end_src

*** DONE Test shuffle
CLOSED: [2025-07-01 Tue 01:56]
#+BEGIN_SRC emacs-lisp :tangle yes
  (ert-deftest-n-times shuffle 100    
    (-let* (((actual-shuffled-list test-list) (funcall (-juxt #'shuffle #'identity) (-iterate-plus-one (math-random-base) (calcFunc-random-255))))
  	      ((actual-shuffled-list-length test-list-length) (seq-map #'seq-length (list actual-shuffled-list test-list))))
  	(should (= actual-shuffled-list-length test-list-length))
  	(should-not (seq-difference actual-shuffled-list test-list))))
#+END_SRC


*** DONE n-random-values-from-array
CLOSED: [2025-07-08 Tue 22:00]
:LOGBOOK:
CLOCK: [2025-07-08 Tue 21:53]--[2025-07-08 Tue 21:57] =>  0:04
CLOCK: [2025-07-08 Tue 19:43]--[2025-07-08 Tue 20:10] =>  0:27
CLOCK: [2025-07-07 Mon 22:27]--[2025-07-07 Mon 22:31] =>  0:04
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times n-random-values-from-array 100
    (-let* (((test-count test-list) (funcall (-compose (-juxt (-compose #'random-integer-in-range (apply-partially #'list 0)  #'seq-length) #'identity)
  						   #'random-integer-list-in-range-255)))
  	 ((actual-random-values actual-length) (funcall (-compose (-juxt #'identity #'seq-length) #'n-random-values-from-array) test-count test-list)))
      (should (eql actual-length test-count))))
      
#+end_src
**** DONE random-array-value
CLOSED: [2025-07-05 Sat 08:34]
:LOGBOOK:
CLOCK: [2025-07-05 Sat 06:37]--[2025-07-05 Sat 06:46] =>  0:09
CLOCK: [2025-07-05 Sat 05:02]--[2025-07-05 Sat 05:09] =>  0:07
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times random-array-value 100
    (-let* (((actual-value test-array) (funcall (-compose (-juxt #'random-array-value #'identity) #'random-integer-list-in-range-255))))
      (should (memq actual-value test-array))))  		     
#+end_src


** DONE Test random-integer-in-range
CLOSED: [2025-06-30 Mon 21:19]
#+begin_src elisp :tangle yes
  (ert-deftest-n-times random-integer-in-range 100    
        (let* ((test-max (random 10000000))
    	   (test-min (- test-max (random test-max) 2))  	   
    	   (actual-integer (random-integer-in-range (list test-min test-max))))
  	(should (integerp actual-integer))
          (should (greater-than-or-equal actual-integer test-min))
          (should (less-than actual-integer test-max))))
#+END_SRC

** DONE Test random-integer-list
CLOSED: [2025-07-01 Tue 05:21]
#+BEGIN_SRC emacs-lisp :tangle yes
  (ert-deftest-n-times random-integer-list 100
    (-let* (((actual-list expected-list-length) (funcall (-juxt #'random-integer-list #'identity) (calcFunc-random-255))))
    (should (eql (seq-count-integers actual-list ) expected-list-length))))
#+END_SRC

** DONE random-integer-range
CLOSED: [2025-07-03 Thu 06:51]
#+BEGIN_SRC emacs-lisp :tangle yes
  (ert-deftest-n-times random-integer-range 100
    (-let* (((actual-range expected-range-length) (funcall (-juxt #'random-integer-range #'identity) (random-integer-in-range (list 1 10000)))))
    (should (eql (range-size actual-range) expected-range-length))))
#+END_SRC


** DONE Test divide-array-values-by-max-array-value
CLOSED: [2025-07-05 Sat 08:34]
:LOGBOOK:
CLOCK: [2025-07-04 Fri 03:16]--[2025-07-04 Fri 03:28] =>  0:12
CLOCK: [2025-07-04 Fri 03:13]--[2025-07-04 Fri 03:14] =>  0:01
:END:
#+begin_src emacs-lisp :tangle yes
  (ert-deftest-n-times divide-array-values-by-max-array-value 100
    (-let* (((actual-list expected-list-length) (funcall (-juxt #'divide-array-values-by-max-array-value #'seq-length)  (random-integer-list-in-range-255))))
      (should (eql (seq-count-between-zero-and-one actual-list) expected-list-length))))
#+end_src

** CANCELLED seq-map-divide-by
:LOGBOOK:
CLOCK: [2025-07-05 Sat 08:47]--[2025-07-05 Sat 08:48] =>  0:01
:END:

** DONE Test divide-by-random-value
CLOSED: [2025-07-07 Mon 19:25]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 19:18]--[2025-07-07 Mon 19:25] =>  0:07
CLOCK: [2025-07-07 Mon 19:16]--[2025-07-07 Mon 19:17] =>  0:01
CLOCK: [2025-07-07 Mon 14:36]--[2025-07-07 Mon 14:56] =>  0:20
:END:
#+begin_src emacs-lisp :tangle yes
  (ert-deftest-n-times divide-by-random-value 100
    (-let* (((actual-result actual-input-value) (funcall (-compose (-juxt #'divide-by-random-value #'identity) #'random-integer-in-range-255))))
      (should (floatp actual-result))
      (should (less-than-or-equal actual-result actual-input-value))))
#+end_src
** CANCELLED Test divide-array-values-by-min-array-value
:LOGBOOK:
CLOCK: [2025-07-04 Fri 05:58]--[2025-07-04 Fri 06:08] =>  0:10
CLOCK: [2025-07-04 Fri 04:33]--[2025-07-04 Fri 05:01] =>  0:28
CLOCK: [2025-07-04 Fri 04:21]--[2025-07-04 Fri 04:23] =>  0:02
:END:
** DONE Test divide-array-values-by-random-value
CLOSED: [2025-07-07 Mon 19:27]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 19:25]--[2025-07-07 Mon 19:27] =>  0:02
CLOCK: [2025-07-07 Mon 19:17]--[2025-07-07 Mon 19:17] =>  0:00
CLOCK: [2025-07-07 Mon 14:30]--[2025-07-07 Mon 14:30] =>  0:00
CLOCK: [2025-07-05 Sat 08:35]--[2025-07-05 Sat 08:40] =>  0:05
:END:
#+begin_src emacs-lisp :tangle yes
  (ert-deftest-n-times divide-array-values-by-random-array-value 100
    (-let* (((actual-list expected-list-length) (funcall (-juxt #'divide-array-values-by-random-value #'seq-length)  (random-integer-list-in-range-255))))
      (should (eql (seq-count-floats actual-list) expected-list-length))))
#+end_src


** TODO Test generate-test-data
*** DONE Lists
CLOSED: [2025-07-07 Mon 21:56]
**** DONE List of integers
CLOSED: [2025-07-07 Mon 21:44]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 21:38]--[2025-07-07 Mon 21:44] =>  0:06
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-list-of-integers 100
      (-let* (((actual-integer-count actual-list-length actual-list)
  	     (funcall (-compose (-juxt #'seq-count-integers #'seq-length #'identity) #'generate-test-data) :min-length 1 :max-length 255)))
        (should (eql actual-integer-count actual-list-length))
        (should (between-one-and-255 actual-integer-count))))
#+END_SRC
**** DONE List of floats between zero and one
CLOSED: [2025-07-07 Mon 21:47]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 21:44]--[2025-07-07 Mon 21:47] =>  0:03
CLOCK: [2025-07-04 Fri 06:17]--[2025-07-04 Fri 06:24] =>  0:07
CLOCK: [2025-07-04 Fri 03:31]--[2025-07-04 Fri 03:31] =>  0:00
CLOCK: [2025-07-04 Fri 03:28]--[2025-07-04 Fri 03:29] =>  0:01
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-list-of-floats-1 100
    (-let* (((actual-floats-count actual-list-length actual-list)
  	     (funcall (-compose (-juxt #'seq-count-floats #'seq-length #'identity) #'generate-test-list-of-floats-between-zero-and-one))))
        (should (eql actual-floats-count actual-list-length))
        (should (between-one-and-255 actual-floats-count))))
#+END_SRC

**** DONE List of floats 
CLOSED: [2025-07-07 Mon 19:29]
:LOGBOOK:
CLOCK: [2025-07-05 Sat 04:44]--[2025-07-05 Sat 05:02] =>  0:18
CLOCK: [2025-07-04 Fri 04:20]--[2025-07-04 Fri 04:21] =>  0:01
CLOCK: [2025-07-04 Fri 04:17]--[2025-07-04 Fri 04:18] =>  0:01
CLOCK: [2025-07-04 Fri 03:32]--[2025-07-04 Fri 03:39] =>  0:07
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-list-of-floats-2 100
      (-let* (((actual-floats-count test-list-length)
  	     (funcall (-compose (-juxt #'seq-count-floats #'seq-length) #'generate-test-list-of-floats))))
        (should (eql actual-floats-count test-list-length))
        (should (between-one-and-255 actual-floats-count))))
#+END_SRC

**** DONE List of strings
CLOSED: [2025-07-07 Mon 21:52]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 21:47]--[2025-07-07 Mon 21:52] =>  0:05
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-list-of-strings 100
      (-let* (((actual-strings-count test-list-length)
  	     (funcall (-compose (-juxt #'seq-count-strings #'seq-length) #'generate-test-list-of-strings))))
        (should (eql actual-strings-count test-list-length))
        (should (between-one-and-255 actual-strings-count))))
#+END_SRC


*** DONE Single String
CLOSED: [2025-07-07 Mon 21:54]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 21:52]--[2025-07-07 Mon 21:55] =>  0:03
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-single-string 100
    (let* ((actual-string (generate-test-string))
  	   (actual-string-length (seq-length actual-string)))
      (should (stringp actual-string))
      (should (between-one-and-255 actual-string-length))))
#+END_SRC

*** TODO vectors
**** DONE vector of integers
CLOSED: [2025-07-07 Mon 21:59]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 21:59]--[2025-07-07 Mon 21:59] =>  0:00
CLOCK: [2025-07-07 Mon 21:55]--[2025-07-07 Mon 21:58] =>  0:03
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-vector-of-integers 100
    (-let* (((actual-integers-count test-vector-length actual-vector)
  	     (funcall (-compose (-juxt #'seq-count-integers #'seq-length #'identity) #'generate-test-vector-of-integers))))
      (should (vectorp actual-vector))
      (should (eql actual-integers-count test-vector-length))
      (should (between-one-and-255 actual-integers-count))))
#+END_SRC


*** alists
**** DONE alist of integers
CLOSED: [2025-07-07 Mon 22:06]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 21:59]--[2025-07-07 Mon 22:06] =>  0:07
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-alist 100
      (-let* (((actual-cons-count actual-alist-length actual-alist) (funcall (-compose (-juxt #'seq-count-cons #'seq-length #'identity) #'generate-test-alist-of-integers))))
        (should (equal actual-cons-count actual-alist-length))
        (should (between-one-and-255 actual-cons-count))))
#+END_SRC

*** con
**** DONE con of integers
CLOSED: [2025-07-08 Tue 22:12]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 22:19]--[2025-07-07 Mon 22:21] =>  0:02
CLOCK: [2025-07-07 Mon 19:29]--[2025-07-07 Mon 19:34] =>  0:05
CLOCK: [2025-07-04 Fri 03:31]--[2025-07-04 Fri 03:32] =>  0:01
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-con-0 100
    (-let (((actual-con actual-car actual-cdr)(funcall (-compose (-juxt #'identity #'car #'cdr) #'generate-test-con-of-integers))))
  	 (should (consp actual-con))
  	 (should (integerp actual-car))
  	 (should (integerp actual-cdr))))
#+END_SRC
**** DONE con of floats
CLOSED: [2025-07-08 Tue 23:38]
:LOGBOOK:
CLOCK: [2025-07-07 Mon 22:21]--[2025-07-07 Mon 22:25] =>  0:04
CLOCK: [2025-07-07 Mon 19:34]--[2025-07-07 Mon 19:36] =>  0:02
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-con-1 100
    (-let (((actual-con actual-car actual-cdr)(funcall (-compose (-juxt #'identity #'car #'cdr) #'generate-test-con-of-floats))))
  	 (should (consp actual-con))
  	 (should (floatp actual-car))
  	 (should (floatp actual-cdr))))
#+END_SRC


**** DONE con of strings
CLOSED: [2025-07-08 Tue 23:41]
#+begin_src elisp :tangle yes
  (ert-deftest-n-times generate-test-data-for-con-2 100
    (-let (((actual-con actual-car actual-cdr)(funcall (-compose (-juxt #'identity #'car #'cdr) #'generate-test-con-of-strings))))
  	 (should (consp actual-con))
  	 (should (stringp actual-car))
  	 (should (stringp actual-cdr))))
#+end_src


* semigroup tests
** concat 
*** TODO string
:LOGBOOK:
CLOCK: [2025-07-08 Tue 23:56]--[2025-07-08 Tue 23:59] =>  0:03
CLOCK: [2025-07-08 Tue 23:52]--[2025-07-08 Tue 23:54] =>  0:02
:END:
#+begin_src elisp :tangle yes
  (ert-deftest-n-times concat-string 100
      (-let* ((test-string-one test-string-two) (generate-test-string))
        ()))
#+end_src
*** TODO list
*** TODO vector
** stimes
*** TODO string
*** TODO list
*** TODO vector
* functor tests
** Functor laws
- [Identity]    @'fmap' 'id' == 'id'@
- [Composition] @'fmap' (f . g) == 'fmap' f . 'fmap' g@
** fmap 
*** fmap for lists
#+begin_src elisp :tangle yes
  (ert-deftest-n-times fmap-for-list 0
    (let* ((test-list (generate-test-data))
  	 (test-list-length (seq-length test-list))
  	 (actual-list (fmap #'1+ test-list)))
      (should (listp actual-list))
      (should (eql (-sum actual-list) (+ (-sum test-list) test-list-length)))))

#+END_SRC
*** fmap for vectors
#+begin_src elisp :tangle yes
  (ert-deftest-n-times fmap-for-vectors 0
    (let* ((test-vector (generate-test-vector-of-integers))
  	 (test-vector-length (seq-length test-vector))
  	 (actual-vector (fmap #'1+ test-vector)))
      (should (vectorp actual-vector))
      (should (eql (-sum actual-vector) (+ (-sum test-vector) test-vector-length)))))

#+END_SRC
** <$
*** <$ for list
#+begin_src elisp :tangle yes
  (ert-deftest-n-times fmap-constantly-for-list 0
    (let* ((test-list (generate-test-data))
  	 (expected-list-length (seq-length test-list))
  	 (test-constant (math-random-base))
  	 (actual-list (<$ test-constant test-list)))
      (should (listp actual-list))
      (should (eql expected-list-length expected-list-length))))

#+END_SRC
*** <$ for vector
#+begin_src elisp :tangle yes
  (ert-deftest-n-times fmap-constantly-for-vector 0
    (let* ((test-vector (generate-test-vector-of-integers))
  	 (expected-vector-length (seq-length test-vector))
  	 (test-constant (math-random-base))
  	 (actual-vector (<$ test-constant test-vector)))
       (should (vectorp actual-vector))
      (should (eql (seq-count (apply-partially eql test-constant)) expected-list-length))))

#+END_SRC
*** <$ for a string
#+begin_src elisp :tangle yes
  (ert-deftest-n-times fmap-constantly-for-string 0
    (let* ((test-string (generate-test-string-of-integers))
  	 (expected-string-length (seq-length test-string))
  	 (test-constant (math-random-base))
  	 (actual-string (<$ test-constant test-string)))
       (should (stringp actual-string))
      (should (eql (seq-count (apply-partially eql test-constant)) expected-list-length))))

#+END_SRC




